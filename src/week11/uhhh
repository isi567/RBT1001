import numpy as np
from scipy.spatial.transform import Rotation
from pprint import pprint

def compute_ik(target_P, target_R, elbow_up=True):

    if target_P is None or target_R is None:
        return None
    
    # 1. find Pw, the wrist position
    Pw = target_P - 0.065 * target_R[:,2]
    print("Pw: ", Pw)

    # 2. find q1, the first joint angle
    q1 = np.arctan2(Pw[1], Pw[0])

    # 3. find Pw' the wrist position in the xy plane
    Pw_prime = np.array([
        np.linalg.norm(Pw[0:2]), 
        Pw[2] - 0.136, 
        0])
    
    print("Pw_prime: ", Pw_prime)
    print("Q1: ", q1)
    

    # 4. find q3 
    c3 = (Pw_prime[0]**2 + Pw_prime[1]**2 - 0.1**2 - 0.107**2) / (2. * 0.1 * 0.107)
    
    # Check if c3 is within valid range [-1, 1]
    if c3 < -1 or c3 > 1:
        print(f"Invalid c3 value: {c3}, position unreachable")
        return None
        
    s3 = np.sqrt(1. - c3**2)  # Only need one solution since we'll handle elbow_up flag

    if elbow_up:
        q3 = np.arctan2(-s3, c3)  # Negative s3 for elbow up
    else:
        q3 = np.arctan2(s3, c3)   # Positive s3 for elbow down
    
    # 5. find q2
    gamma = np.arctan2(Pw_prime[1], Pw_prime[0])
    beta = np.arctan2(0.107 * np.sin(q3), 0.1 + 0.107 * np.cos(q3))
    q2 = gamma - beta
    
    # Adjust angles to match robot's joint configuration
    q2 = -q2 - 3*np.pi/2.
    q3 = -q3 - np.pi/2.


    print("Q2: ", q2)
    print("Q3: ", q3)

    # Now we know R0123 and R0123456, we can find R456
    R0123 = Rotation.from_matrix([
        [-np.cos(q1)*np.cos(q2+q3), np.sin(q2+q3)*np.cos(q1), -np.sin(q1)],
        [-np.sin(q1)*np.cos(q2+q3), np.sin(q1)*np.sin(q2+q3), np.cos(q1)],
        [ np.sin(q2+q3), np.cos(q2+q3), 0]
    ]).as_matrix()
    R456 = R0123.T @ target_R

    print(R456)

    # Handle singular case where q5 is near 0 or pi
    if np.isclose(abs(R456[1,2]), 1.0):
        # Singular case - set q5 and choose arbitrary q4, q6
        q5 = 0.0 if R456[1,2] > 0 else np.pi
        q4 = 0.0  # Arbitrary choice
        q6 = np.arctan2(R456[0,1], R456[0,0])
    else:
        # Non-singular case
        q5 = np.arccos(R456[1,2])
        q4 = np.arctan2(R456[2,2], -R456[0,2])
        q6 = np.arctan2(R456[1,0], R456[1,1])
    
    q6 = q6 - np.pi  # Adjust for robot configuration

    print("Q4: ", q4)
    print("Q5: ", q5)
    print("Q6: ", q6)
    

    # Check that none of the angles are NaN
    if np.isnan(q1) or np.isnan(q2) or np.isnan(q3) or np.isnan(q4) or np.isnan(q5) or np.isnan(q6):
        return None
    
    return [q1, q2, q3, q4, q5, q6]


def main():
    # Example target position and orientation
    target_position = np.array([0.03, -0.37, 0.0])  # Example position (x, y, z)
    target_orientation_quat = [0.0, 0.0, 0.0, 1]  # Example quaternion (x, y, z, w)

    # Convert quaternion to rotation matrix
    target_orientation_matrix = Rotation.from_quat(target_orientation_quat).as_matrix()

    print("Target Position:")
    pprint(target_position)
    print("Target Orientation (Rotation Matrix):")
    pprint(target_orientation_matrix)

    # Compute the IK solution
    joint_angles = compute_ik(target_position, target_orientation_matrix)

    if joint_angles is not None:
        print("Computed Joint Angles:")
        pprint(joint_angles)
    else:
        print("Failed to compute IK solution.")


if __name__ == '__main__':
    main()